/**\n * Enhanced Audio Worklet Processor for Voice Assistant\n * Supports binary audio streaming for better performance\n */\n\nclass AudioStreamerWorklet extends AudioWorkletProcessor {\n  constructor() {\n    super();\n    \n    this.bufferSize = 1024;\n    this.sampleRate = 16000;\n    this.channels = 1;\n    this.inputBuffer = [];\n    this.chunkSequence = 0;\n    this.isRecording = false;\n    \n    // Binary audio support\n    this.binaryMode = false;\n    this.vadEnabled = false;\n    this.silenceThreshold = 0.01;\n    this.silenceFrames = 0;\n    this.maxSilenceFrames = 50; // ~1.5s at 30ms frames\n    \n    // Message handling\n    this.port.onmessage = (event) => {\n      this.handleMessage(event.data);\n    };\n  }\n  \n  handleMessage(data) {\n    switch (data.type) {\n      case 'start':\n        this.isRecording = true;\n        this.inputBuffer = [];\n        this.chunkSequence = 0;\n        this.silenceFrames = 0;\n        this.bufferSize = data.chunkSize || 1024;\n        this.binaryMode = data.binaryMode || false;\n        this.vadEnabled = data.vadEnabled || false;\n        break;\n        \n      case 'stop':\n        this.isRecording = false;\n        this.flushBuffer();\n        break;\n        \n      case 'config':\n        this.sampleRate = data.sampleRate || 16000;\n        this.silenceThreshold = data.silenceThreshold || 0.01;\n        this.maxSilenceFrames = data.maxSilenceFrames || 50;\n        break;\n    }\n  }\n  \n  process(inputs, outputs, parameters) {\n    const input = inputs[0];\n    \n    if (!this.isRecording || !input || !input[0]) {\n      return true;\n    }\n    \n    const inputData = input[0]; // First channel\n    \n    // Resample if needed (48kHz -> 16kHz)\n    const resampledData = this.resample(inputData, this.sampleRate);\n    \n    // Add to buffer\n    this.inputBuffer.push(...resampledData);\n    \n    // VAD processing\n    if (this.vadEnabled) {\n      const energy = this.calculateEnergy(resampledData);\n      if (energy < this.silenceThreshold) {\n        this.silenceFrames++;\n        if (this.silenceFrames >= this.maxSilenceFrames) {\n          this.port.postMessage({\n            type: 'vad_silence_detected',\n            sequence: this.chunkSequence\n          });\n          this.isRecording = false;\n          return true;\n        }\n      } else {\n        this.silenceFrames = 0;\n      }\n    }\n    \n    // Send chunks when buffer is full\n    while (this.inputBuffer.length >= this.bufferSize) {\n      const chunk = this.inputBuffer.splice(0, this.bufferSize);\n      this.sendChunk(chunk);\n    }\n    \n    return true;\n  }\n  \n  resample(inputData, targetSampleRate) {\n    // Simple downsampling from 48kHz to 16kHz (3:1 ratio)\n    if (targetSampleRate === 16000) {\n      const ratio = 3;\n      const output = new Float32Array(Math.floor(inputData.length / ratio));\n      for (let i = 0; i < output.length; i++) {\n        output[i] = inputData[i * ratio];\n      }\n      return output;\n    }\n    return inputData;\n  }\n  \n  calculateEnergy(data) {\n    let sum = 0;\n    for (let i = 0; i < data.length; i++) {\n      sum += data[i] * data[i];\n    }\n    return Math.sqrt(sum / data.length);\n  }\n  \n  sendChunk(chunk) {\n    if (this.binaryMode) {\n      // Convert to PCM16 binary format\n      const pcm16Data = new Int16Array(chunk.length);\n      for (let i = 0; i < chunk.length; i++) {\n        pcm16Data[i] = Math.max(-32768, Math.min(32767, chunk[i] * 32768));\n      }\n      \n      this.port.postMessage({\n        type: 'chunk_binary',\n        data: pcm16Data.buffer,\n        sequence: this.chunkSequence++,\n        length: chunk.length\n      }, [pcm16Data.buffer]);\n    } else {\n      // Traditional base64 JSON format\n      const pcm16Data = new Int16Array(chunk.length);\n      for (let i = 0; i < chunk.length; i++) {\n        pcm16Data[i] = Math.max(-32768, Math.min(32767, chunk[i] * 32768));\n      }\n      \n      this.port.postMessage({\n        type: 'chunk_base64',\n        data: Array.from(pcm16Data),\n        sequence: this.chunkSequence++,\n        length: chunk.length\n      });\n    }\n  }\n  \n  flushBuffer() {\n    if (this.inputBuffer.length > 0) {\n      this.sendChunk(this.inputBuffer);\n      this.inputBuffer = [];\n    }\n  }\n}\n\nregisterProcessor('audio-streamer-worklet', AudioStreamerWorklet);\n