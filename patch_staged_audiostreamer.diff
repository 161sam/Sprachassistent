*** a/voice-assistant-apps/shared/core/AudioStreamer.js
--- b/voice-assistant-apps/shared/core/AudioStreamer.js
@@
 export default class AudioStreamer {
   constructor(context) {
     this.ctx = context || new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
     this.node = null;
     this.port = null;
     this.ready = false;
   }
 
   async init() {
     if (this.ready) return;
     await this.ctx.audioWorklet.addModule('/workers/audio-streaming-worklet.js');
     this.node = new AudioWorkletNode(this.ctx, 'audio-streaming-worklet');
     this.port = this.node.port;
     this.node.connect(this.ctx.destination);
     this.ready = true;
     console.log('[AudioStreamer] ready');
   }
 
+  // ---- Staged TTS (JSON) ----
+  /**
+   * Erwartet msg: { op:'staged_tts_chunk', sampleRate:48000, format:'f32', pcm:'<base64>' }
+   */
+  handleStagedChunkJSON(msg) {
+    if (!this.ready) return;
+    if (!msg || msg.op !== 'staged_tts_chunk') return;
+    const sr = msg.sampleRate || 48000;
+    const fmt = (msg.format || 'f32').toLowerCase();
+    const b64 = msg.pcm;
+    if (!b64) return;
+    const pcm = this._b64ToFloat32(b64);
+    this._enqueueFloat32(pcm, sr);
+  }
+
+  handleStagedEnd() {
+    if (!this.ready) return;
+    this.port.postMessage({ type: 'flush' });
+  }
+
+  // ---- Binary v2 (optional) ----
+  async handleBinaryFrame(blob) {
+    if (!this.ready) return;
+    // Erwartetes Layout (vereinfachter Fallback):
+    // [header(json as text)  -> 0..N ][raw PCM Float32 bytes]
+    const buf = await blob.arrayBuffer();
+    // Heuristik: JSONâ€‘Header endet mit \n\n
+    const bytes = new Uint8Array(buf);
+    let split = -1;
+    for (let i = 1; i < bytes.length; i++) {
+      if (bytes[i-1] === 10 && bytes[i] === 10) { split = i+1; break; } // \n\n
+    }
+    if (split < 0) return;
+    const headerText = new TextDecoder('utf-8').decode(bytes.slice(0, split));
+    let meta = null;
+    try { meta = JSON.parse(headerText.trim()); } catch { /* ignore */ }
+    if (!meta || meta.op !== 'staged_tts_chunk') return;
+    const sr = meta.sampleRate || 48000;
+    const f32 = new Float32Array(buf, split);
+    this._enqueueFloat32(f32, sr);
+  }
+
+  _enqueueFloat32(f32, sampleRate) {
+    if (this.ctx.sampleRate !== sampleRate) {
+      // Resampling im Worklet vermeiden: packe Metadaten mit
+      this.port.postMessage({ type: 'config', sampleRate });
+    }
+    this.port.postMessage({ type: 'audio', format: 'f32', data: f32 }, [f32.buffer]);
+  }
+
+  _b64ToFloat32(b64) {
+    const bin = atob(b64);
+    const len = bin.length;
+    const buf = new ArrayBuffer(len);
+    const view = new Uint8Array(buf);
+    for (let i = 0; i < len; i++) view[i] = bin.charCodeAt(i);
+    return new Float32Array(buf);
+  }
 }
